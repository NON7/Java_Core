# 1.什么是线程

| 方法                          | 含义                                                         | 备注                                       |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------ |
| Thread(Runnable target)       | 构造一个新线程，调用指定目标的run()方法                      |                                            |
| void start()                  | 启动这个线程，从而调用run()方法，这个方法会立即返回，新线程会并发运行 |                                            |
| void run()                    | 调用相关Runnable的run方法                                    | 必须覆盖这个方法，提供你希望执行的任务指令 |
| statc void sleep(long millis) | 休眠指定的毫秒数                                             |                                            |
| static void yield()           | 使当前正在执行的线程向另一个线程交出运行权。即让出CPU使用权  | 注意这是一个静态方法                       |

### 实现线程的方式一：实现Runnable接口

#### 1.将执行这个任务的代码放在一个类的run方法中，这个类要实现Runnable接口

```java
//Runnable接口
public interface Runnable{
	void run()
}
```

<a font="red">由于Runnable接口是一个函数式接口，可以用lambda表达式创建一个实例</a>

```java
Runnable r=()->{
    task code 
};
```

#### 2.从这个Runnable构造一个Thread对象

```java
var t=new Thread(r);
```

#### 3.启动线程

```java
t.start();
```

### 实现线程的方式二：继承Thread类

```java
class MyThread extends Thread{
	public void run(){
        task code;
    }
}
```

> 不推荐此种方法，耦合性太高

> <a font="red">注意：不要调用Thread类或Runnable对象的run方法，直接调用run方法只会在同一个线程中执行这个任务，而没有启动新的线程。实际上，应当调用Thread.start方法，这回创建一个执行run方法的新线程。</a>







# 2.线程状态

| 状态           | 含义     | 备注                                                         |
| -------------- | -------- | ------------------------------------------------------------ |
| New            | 新键     | new Thread(r)后，新键线程                                    |
| Runnable       | 可运行   | 调用start()方法，线程转为就绪状态（即可运行），但不一定拿到CPU |
| Blocked        | 阻塞     |                                                              |
| Waiting        | 等待     |                                                              |
| Timed wwaiting | 计时等待 |                                                              |
| Terminated     | 终止     |                                                              |



### 1.新键线程

​	当用new操作符创建一个新线程时，如new Thread(r)，这个线程还没开始运行，这意味着它的状态是新键（new），当一个线程处于新键状态时，程序还没有开始运行线程中的代码，在线程运行之前还有一些基础工作要做

### 2.可运行线程

​	一旦调用start方法，线程就处于可运行（runnable）状态。一个可运行的线程可能正在运行，也可能没有运行，要由操作系统为线程提供具体的运行时间。

### 3.阻塞和等待线程

当线程处于阻塞或等待状态时，他暂时是不活动的。它不运行任何代码，且消耗最少的资源，要由线程调度器重新激活这个线程。

- #### 阻塞

  - 当一个线程试图获取一个内部的对象所，而这个锁目前被其他线程占用，该线程就会被阻塞，当所有其他线程都释放了这个锁，并且调度器允许该线程持有这个锁时，它将变成非阻塞状态；

- #### 等待

  - 当线程等待另一个线程通知调度器出现一个条件时，这个线程会进入等待状态

  - ```java
    1.Object.wait()
    2.Thread.join()
    3.等待java.util.concurrent库中的Lock或Condition时，会出现这种情况
    ```

    

- #### 计时等待

  - 有几个方法有超时参数，调用这些方法会让线程进入计时等待状态

  - ```java
    1.Thread.sleep()
    2.Object.wait()
    3.Thread.join()
    4.Lock.tryLock()
    5.Condition.await()
    ```

![](C:\Users\娟\Desktop\笔记\Java核心技术 第11版笔记\第12章 并发.assets\2.PNG)

### 4.终止线程

线程会由于一下两个原因之一而终止：

- run方法正常退出，线程自然终止
- 因为一个没有捕获的异常终止了run方法，使线程意外终止

具体来说，可以调用线程的stop方法杀死一个线程，该方法抛出一个ThreadDeath错误对象，这回杀死线程，不过stop方法已经废弃，不要在你自己的代码中调用这个方法

| 方法                    | 含义                                                         | 备注 |
| ----------------------- | ------------------------------------------------------------ | ---- |
| void join()             | 等待终止指定的线程                                           |      |
| void join(long millis)  | 等待指定的线程终止或等经过指定的毫秒数                       |      |
| Thread.State getState() | 得到这个线程的状态，取值为:NEW/RUNNABLE/BLOCKED/WAITING/TIMED_WAITING/TERMINATED |      |
| void stop()             | 停止该线程，这个方法已经废弃                                 | 废弃 |
| void suspend()          | 暂停这个线程的执行，这个方法已经废弃                         | 废弃 |
| void resume()           | 恢复线程，这个方法只能在调用suspend（）之后使用，已经废弃    | 废弃 |

# 3.线程属性

### 1.中断线程

​		当线程的run方法执行方法体中最后一条语句后再执行return语句返回时，或者出现了方法中没有捕获的异常是，线程将终止。除了已经废弃的stop方法，没有办法可以强制终止线程。不过，interrupt方法可以用来请求终止一个线程。

​	当对一个线程调用interrupt方法时，就会设置线程的中断状态。这时每个线程都有的boolean标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断。

1.判断是否设置了中断状态

```java
while(!Thread.currentThread().isInterrupted&&moren work to do){
    do more work;
}
```

- 但是，如果线程被阻塞，就无法检查中断状态。这里就要引入InterruptedException异常。
  - 当一个被sleep或wait调用阻塞的线程上调用interrupt方法时，那个阻塞调用（sleep或wait调用）将被一个InterruptedException异常中断。

- ​	存在一种情况，线程中断不是希望终止，而是可以决定如何响应中断。线程有时只希望将中断解释为一个终止请求。这种线程的run方法写法如下：


```java
Runnable r=()->{
    try{
        ...
        while(!Thread.currentThread().isInterrupted()&&more work to do){
            //do more work
        }
    }catch(InterruptedException e){
        //Thread was interrupted during sleep or wait
    }finally{
        cleanup,if required
    }    
    //existing the run method terminates the thread
}
```

- 如果你循环调用了sleep，不要检测中断状态，而应当捕获InterruptedException异常
  - 因为如果在每次工作迭代之后都调用sleep方法（或其他可中断方法），isInterrupted检查无用且必要，如果设置了中断状态，此时倘若调用sleep方法，他不会休眠而是会清楚中断状态并且抛出InterruptedException。写法如下：

```java
Runnable r=()->{
    try{
        while(more work to do){
            //do more work
            Thread.sleep(delay)
        }
    }catch(InterruptedException e){
        //thread was interrupted during sleep
    }finally{
        //cleanup, if reuqired
    }
    //existing the run method terminates the thread
}
```

> 小结：
>
> interrupted（）：一个静态方法，用于检查当前线程是否被中断，并且调用interrupted方法会清楚该线程的中断状态。
>
> isInterrupted（）：一个实例方法，可以用来检查是否有线程被中断，调用这个方法不会改变中断状态

- 不要抑制InterruptedException中断，而是检测中断和捕获异常

  ```java
  //不可取
  void mySubTask(){
      try{
          sleep(delay);
      }catch(InterruptedException e){}
  }
  ```

  - 检测中断：在catch子句中调用Thread.currentThread().interrupt()来设置中断状态。

    ```java
    //不可取
    void mySubTask(){
        try{
            sleep(delay);
        }catch(InterruptedException e){
            Thread.currentThread().interrupt()
        }
    }
    ```

  - 捕获异常：用throw InterruptedException标记你的方法，去掉try语句块。这样调用者（或最终的run方法）可以捕获这个异常

    ```java
    //不可取
    void mySubTask throws InterruptedException(){
        sleep(delay);
    }     
    ```

| 方法                          | 含义                                                         | 备注                              |
| ----------------------------- | ------------------------------------------------------------ | --------------------------------- |
| void interrupt()              | 向线程发送中断请求。线程的中断状态将被置为true。如果当前线程被一个sleep调用阻塞，则跑出一个InterruptedException异常 |                                   |
| static boolean interrupted()  | 测试当前线程是否被中断                                       | 它将当前线程的中断状态重置为false |
| boolean isInterrupted()       | 测试线程是否被中断                                           | 这个调用不改变线程的中断状态      |
| static Thread currentThread() | 返回表示当前正在执行的线程的Thread对象                       |                                   |



### 2.守护线程

- 作用：为其他线程提供服务，当只剩守护线程时，虚拟机会退出。

- 转换方法：

  | 方法                             | 含义                                                         | 备注 |
  | -------------------------------- | ------------------------------------------------------------ | ---- |
  | void setDaemon(boolean isDaemon) | 标识该线程为守护线程或用户线程，这一方法必须在线程启动之前调用 |      |

### 3.线程名

默认情况下，线程有容易记的名字，可以用setName方法为线程设置任何名字

```java
var t=new Thread(runnable);
t.setName{"Web crawler"};
```

### 4.未捕获异常的处理器

- 线程的run方法不能抛出任何检查型异常

- 非检查型异常可能会导致线程终止

  - 这种情况下，线程会死亡，死亡之前，异常会传递到一个用于处理未捕获异常的处理器。这个处理器必须属于一个实现了Thread.UncaughtExceptionHandler接口的类。这个接口只有一个方法

  ```java
  void uncaughtException(Thread t,Throwable e)
  ```

> <a font="red">未捕获异常的处理器，是线程终止之前，最后向操作者抛出异常的地方，可以用三种方法捕捉这种异常，用于处理</a>

处理异常的三种方法：

- 方法一：给任何线程安装处理器
  - 用setUncaughtExceptionHandler方法为任何线程安装一个处理器
- 方法二：为所有线程安装一个默认的处理器
  - 用Thread类的静态方法setDefaultUncaughtExceptionHandler为所有线程安装一个默认处理器。替代处理器可以使用API将未捕获异常的报告发送到一个日志文件
- 方法三：没有安装默认处理器
  - 默认处理器则为null，若也没有为单个线程安装处理器，name处理器就是该线程的ThreadGroup对象

> <a font="red">线程组是可以一起管理的线程的集合，默认情况下，创建的所有线程都属于同一个线程组，但是也可以建立其他的组（建议不要）</a>

​		ThreadGroup类实现了Thread.UncaughtExceptionHandler接口，他的uncaughtException方法执行以下操作：

- 如果该线程组有父线程组，那么调用父线程组的uncaughtException方法。
- 否则，如果Thread.getDefaultExceptionHandler方法返回一个非null的处理器，则调用该处理器。
- 否则，如果Throwable是ThreadDeath的一个实例，什么都不做。
- 否则，将线程的名字以及Throwable的栈归集输出到System.err

| 方法                                                         | 含义                                                         | 备注 |
| ------------------------------------------------------------ | :----------------------------------------------------------- | ---- |
| static void setDefaultUncaughtExceptionHandler(Thread.UncaughtException handler) |                                                              |      |
| static Thread.UncaughtExceptionHandler getDefaultUncaughtExceptionHandler() | 设置或获取未捕获异常的默认处理器                             |      |
| void setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler) |                                                              |      |
| Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() | 设置或获取未捕获异常的处理器。如果没有安装处理器，则将线程组对象作为处理器 |      |

### 5.线程优先级

- 线程优先级依赖操作系统
- 默认情况下，一个线程会继承构造他的那个线程的优先级，可以用setProprity方法提高或降低任何一个线程的优先级

| 方法                              | 含义                                          | 备注                                                         |
| --------------------------------- | --------------------------------------------- | ------------------------------------------------------------ |
| void setProprity(int newPriority) | 设置线程的优先级。                            | 优先级必须在Thread.MIN_PRIORITY与Thread.MAX_PRIORITY之间，一般使用Thread.NORM_PRIORITY |
| static int MIN_PRIORITY           | 是Thread可以有的最小优先级，最小优先级的值为1 |                                                              |
| static int NORM_PRIORITY          | Thread的默认优先级，默认优先级为5             |                                                              |
| static int MAX_PRIORITY           | 是Thread可以有的最大优先级，最大优先级为10    |                                                              |



# 4.同步

> 问：什么是同步？
>
> 答：
>
> 

### 1.竞态条件

- 竞态条件定义：多个线程访问统一对象并且均==修改该对象状态==的情况下，两线程相互覆盖。==对象状态取决于线程访问次序==而不是调用逻辑（失控），此为竞态条件。

- 竞态条件产生原因：两个以上线程存取统一对象，并且每个线程分别调用了一个修改该对象状态的方法。

### 2.锁对象--解决并发访问临界区的问题

有两种机制可以防止并发访问代码块

- synchronized关键字

- Java5引入的ReentrantLock类

  - 这个结构确保任何时刻只有一个线程进入临界区，一旦一个线程锁定了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，他们会暂停，直到第一个线程释放这个锁对象

  ```java
  myLock.lock();//a ReetrantLock object
  try{
  	critical section
  }finally{
  	myLock.unlock();//make sure the lock is unlocked even if an exception is thrown
      //unlock（）方法必须放在finally子句中，如果在临界区的代码抛出一个异常，锁必须释放，否则，其他线程将永远阻塞。
  }
  ```

  

- 重入锁
  
  - ==他表示该锁能够支持一个线程对资源的重复加锁==

> <a font>注意确保临界区中的代码不要因为抛出异常而跳出临界区。如果在临界区代码结束之前抛出异常，finally子句将释放锁，但是对象可能处于被破坏的状态</a>

| 方法                        | 含义                                                         | 备注                                            |
| --------------------------- | ------------------------------------------------------------ | ----------------------------------------------- |
| void lock()                 | 获得这个锁，如果锁当前被另一个线程占用，则阻塞（关门，上锁，别让其他线程进来） | JAVA5--java.util.concurrent.locks.Lock          |
| void unlock()               | 释放这个锁（把锁打开，门开开，让里面的线程出去）             | JAVA5--java.util.concurrent.locks.Lock          |
| ReentrantLock()             | 构造一个重入锁，可以用来保护临界区（给加了锁的线程和临界区，再加个锁） | JAVA5--java.util.concurrent.locks.ReentrantLock |
| ReentrantLock(boolean fair) | 构造一个采用公平策略的锁。一个公平锁倾向于等待时间最长的线程。不过这种公平保证可能严重影响性能，所以，默认情况下，不要求锁是公平的 | JAVA5--java.util.concurrent.locks.ReentrantLock |



### 3.条件对象--解决线程进入临界区后发现缺少执行条件



### 4.synchronized关键字

### 5.同步块

### 6.监视器概念

### 7.volatile字段

### 8.final变量

### 9.原子性

### 10.死锁

### 11.线程局部变量

### 12.为什么废弃stop和suspend方法



# 5.线程安全的集合

### 1.阻塞队列

### 2.高效的映射、集和队列

### 3.映射条目的原子更新

### 4.对并发散列映射的批操作

### 5.并发集视图

### 6.写数组的拷贝

### 7.并行数组算法

### 8.较早的线程安全集合



# 6.任务和线程池

### 1.Callable与Future

### 2.执行器

### 3.控制任务组

### 4.fork-join框架



# 7.异步计算

### 1.可完成Future

### 2.组合可完成Future

### 3.用户界面回调中的长时间运行任务



# 8.进程

### 1.建立一个进程

### 2.运行一个进程

### 3.进程句柄